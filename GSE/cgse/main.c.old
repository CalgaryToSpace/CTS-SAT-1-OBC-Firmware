#include "main.h"
#include "terminal.h"
#include "command_history.h"
#include "command_queue.h"
#include "commands.h"

#include "telecommands/telecommand_definitions.h"

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/termios.h>
#include <termios.h>
#include <stdbool.h>
#include <string.h>
#include <signal.h>

#include <ncurses.h>
#include <errno.h>

#include <time.h>
#include <sys/time.h>


volatile sig_atomic_t running = 1;
volatile uint8_t TASK_heartbeat_is_on = 0;
int lfs = 0;
uint8_t LFS_is_lfs_mounted = 0;

extern const int16_t TCMD_NUM_TELECOMMANDS;
extern const TCMD_TelecommandDefinition_t TCMD_telecommand_definitions[];
extern const int CGSE_NUM_TERMINAL_COMMANDS; 
extern const CGSE_command_t CGSE_terminal_commands[];

static void interrupthandler(int sig)
{
    (void)sig;
    running = 0;

    return;
}

int main(int argc, char **argv)
{

    CGSE_program_state_t program_state = {0};
    CGSE_program_state_t *ps = &program_state;

    ps->argc = argc;
    ps->argv = argv;
    int arg_status = parse_args(ps);
    if (arg_status != 0) {
        return EXIT_FAILURE;
    }

    int init_status = CGSE_init(ps);
    if (init_status != 0) {
        return EXIT_FAILURE;
    }

    while(running) {
        update_link_status(ps);
        parse_telemetry(ps);
        process_command_queue(ps);
        parse_input(ps);
        usleep(IO_WAIT_USEC);
    }

    CGSE_shutdown(ps);

    return EXIT_SUCCESS;
}

int parse_args(CGSE_program_state_t *ps)
{
    int status = 0;

    ps->program_start_epoch_ms = current_time() * 1000;

    ps->baud_rate = CGSE_DEFAULT_BAUD_RATE;
    ps->command_prefix = CGSE_DEFAULT_TELECOMMAND_PREFIX;
    ps->auto_connect = true;
    ps->prepend_timestamp = false;
    snprintf(ps->current_directory, FILENAME_MAX, "%s", ".");

    char *history_path = getenv("HOME");
    snprintf(ps->command_history_file_path, FILENAME_MAX, "%s/%s", history_path != NULL ? history_path : "", CGSE_COMMAND_HISTORY_FILENAME);
    snprintf(ps->command_startup_queue_file_path, FILENAME_MAX, "%s/%s", history_path != NULL ? history_path : "", CGSE_COMMAND_STARTUP_QUEUE_FILENAME);

    char *arg = NULL;

    for (int i = 1; i < ps->argc; i++) {
        arg = ps->argv[i];
        if (strncmp("--link=", arg, 7) == 0) {
            if (strlen(arg) < 8) {
                fprintf(stderr, "Unable to interpret %s\n", arg);
                return EXIT_FAILURE;
            }
            snprintf(ps->satellite_link_path, FILENAME_MAX, "%s", arg + 7);
            ps->nOptions++;
        }
        else if (strncmp("--baud-rate=", arg, 12) == 0) {
            if (strlen(arg) < 13) {
                fprintf(stderr, "Unable to interpret %s\n", arg);
                return EXIT_FAILURE;
            }
            ps->baud_rate = atoi(arg + 12);
            ps->nOptions++;
        }
        else if (strncmp("--command-prefix=", arg, 17) == 0) {
            if (strlen(arg) < 18) {
                fprintf(stderr, "Unable to interpret %s\n", arg);
                return EXIT_FAILURE;
            }
            ps->command_prefix = arg + 17;
            ps->nOptions++;
        }
        else if (strncmp("--command-history-filename=", arg, 27) == 0) {
            if (strlen(arg) < 28) {
                fprintf(stderr, "Unable to interpret %s\n", arg);
                return EXIT_FAILURE;
            }
            snprintf(ps->command_history_file_path, FILENAME_MAX, "%s", arg + 27);
            ps->nOptions++;
        }
        else if (strncmp("--commands=", arg, 11) == 0) {
            if (strlen(arg) < 12) {
                fprintf(stderr, "Unable to interpret %s\n", arg);
                return EXIT_FAILURE;
            }
            snprintf(ps->command_optional_queue_file_path, FILENAME_MAX, "%s", arg + 11);
            ps->nOptions++;
        }
        else if (strcmp("--no-auto-connect", arg) == 0) {
            ps->auto_connect = false;
            ps->nOptions++;
        }
        else if (strcmp("--about", arg) == 0) {
            CGSE_about();
            return 1;
        }
        else if (strcmp("--license", arg) == 0) {
            CGSE_license();
            return 1;
        }
        else if (strcmp("--help", arg) == 0) {
            CGSE_commandline_help(ps->argv[0]);
            return 1;
        }
        else {
            fprintf(stderr, "Unrecognized option %s\n", arg);
            return EXIT_FAILURE;
        }

    }

    if (ps->argc - ps->nOptions != 1) {
        CGSE_commandline_help(ps->argv[0]);
        return EXIT_FAILURE;
    }

    if (strlen(ps->satellite_link_path) == 0) {
        snprintf(ps->satellite_link_path, FILENAME_MAX, "/dev");
        CGSE_find_link_path(ps->satellite_link_path);
    }

    return 0;
}

void CGSE_license(void)
{
    fprintf(stdout, "MIT License. Etc.\n");

    return;
}

void CGSE_about(void)
{
    fprintf(stdout, "Fast, lightweight GSE terminal for FrontierSat communications.\n");
    fprintf(stdout, "Copyright (C) Johnathan K Burchill (2025)\n");

    return;
}

void CGSE_commandline_help(char *name)
{
    fprintf(stdout, "usage: %s [option] ...\n", name);

    fprintf(stdout, "Options:\n");
    fprintf(stdout, "%30s -- %s\n", "--link=<path>", "Set the satellite link path. Chosen automatically by default.");
    fprintf(stdout, "%30s -- %s%d.\n", "--baud-rate=<rate>", "Set the satellite link baud rate. Default: ", CGSE_DEFAULT_BAUD_RATE);
    fprintf(stdout, "%30s -- %s\n", "--no-auto-connect", "Start program without connecting to satellite.");
    fprintf(stdout, "%30s -- %s\n", "--command-prefix=<prefix>", "Telecommand prefix. Default: " CGSE_DEFAULT_TELECOMMAND_PREFIX );
    fprintf(stdout, "%30s -- %s\n", "--command-history-filename=<filename>", "Command history filename. Default: ${HOME}/" CGSE_COMMAND_HISTORY_FILENAME);
    fprintf(stdout, "%30s -- %s\n", "--commands=<filename>", "Queue commands from <filename>.");

    return;
}

/// time_str must be large enough to store 32 chars
void CGSE_time_string(char *time_str)
{
    struct timeval tv = {0};
    gettimeofday(&tv, NULL);
    struct tm *t = gmtime(&tv.tv_sec);
    snprintf(time_str, CGSE_TIME_STR_MAX_LEN, "UTC=%4d-%02d-%02dT%02d:%02d:%02d.%06d", t->tm_year+1900, t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec, tv.tv_usec);
    char *result = strdup(time_str);

    return;
}

int CGSE_init(CGSE_program_state_t *ps)
{
    int status = 0;

    struct sigaction intact = {0};
    intact.sa_handler = interrupthandler;
    sigaction(SIGINT, &intact, NULL);

    char timestr[33] = {0}
    CGSE_time_string(timestr);
    snprintf(ps->log_file_path, FILENAME_MAX, "log-file-%s.log", timestr);
    ps->logfile = fopen(ps->log_file_path, "w");
    if (ps->logfile == NULL) {
        fprintf(stderr, "Unable to initialize log file %s.\n", ps->log_file_path);
        return EXIT_FAILURE;
    }

    status = init_terminal_screen(ps);
    if (status != 0) {
        endwin();
        fprintf(stderr, "Unable to initialize ncurses screen.\n");
        return EXIT_FAILURE;
    }
    
    if (ps->auto_connect) {
        CGSE_terminal_connect(ps, ".connect");
    }

    int read_history_res = CGSE_read_command_history(ps);
    if (read_history_res != 0) {
        CGSE_store_command("");
    }

    CGSE_load_command_queue(ps);

    // Draw the command line
    wmove(ps->command_window, ps->line, 0);
    wprintw(ps->command_window, "%s> %s", ps->command_prefix, ps->command_buffer);
    wrefresh(ps->command_window);

    return 0;
}

void CGSE_shutdown(CGSE_program_state_t *ps) 
{
    if (ps->satellite_connected && ps->satellite_link > 0) {
        close(ps->satellite_link);
    }

    int write_status = CGSE_write_command_history(ps);
    if (write_status != 0) {
        fprintf(stderr, "Error writing command history.\n");
    }
    CGSE_free_command_history();

    // TODO maybe write out remaining commands in the command queue for later
    // processing?
    CGSE_free_command_queue();

    CGSE_terminal_shutdown();

    fclose(ps->logfile);
    fflush(ps->logfile);

    return;

}
